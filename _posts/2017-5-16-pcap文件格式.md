---
title: pcap文件格式
tags: 其他
grammar_cjkRuby: true
---


## pcap是什么 ##
pcap是一种数据流格式，wireshark软件可以直接把网络数据流变成这种格式。
在Linux里，pcap可以说是一种通用的数据流格式，很多开源的项目都需要用到这种格式的文件。
ROHC的库里，测试脚本的入口参数之一就是一个pcap格式的数据流文件。
如果清楚了pcap的格式，就可以自己去生成数据流文件，从而去使用ROHC的库。

## pcap格式 ##  
![pcap格式]({{ site.baseurl }}/_posts/images/1494596639754.png)

上图是pcap的格式结构图，分成两大部分：

> 
 - **Global Header （共 24 Byte）**
 整个数据流文件，只会有一个 Global Header，它定义了本文件的**读取规则**、**最大储存长度限制**等内容；
 
![图2]({{ site.baseurl }}/_posts/images/1494596652740.png)

  - **Magic：4Byte：**标记文件开始，并用来识别文件自己和字节顺序。0xa1b2c3d4用来表示按照原来的顺序读取，0xd4c3b2a1表示下面的字节都要交换顺序读取。考虑到计算机内存的存储结构，一般会采用**0xd4c3b2a1**，即**所有字节都需要交换顺序读取**。
  - **Major：2Byte：** 当前文件主要的版本号，一般为 **0x0200**【*实际上因为需要交换读取顺序，所以计算机看到的应该是 0x0002*】
  - **Minor：2Byte：** 当前文件次要的版本号，一般为 **0x0400**【*计算机看到的应该是 0x0004*】
  - **ThisZone：4Byte：**当地的标准时间，如果用的是GMT则全零，一般都直接写 **0000 0000**
  - **SigFigs：4Byte：**时间戳的精度，设置为 **全零** 即可
  - **SnapLen：4Byte：**最大的存储长度，如果想把整个包抓下来，设置为 ffff 0000，但一般来说 **ff7f 0000**就足够了【*计算机看到的应该是 0000 ff7f* 】
  - **LinkType：4Byte：**链路类型，常用类型有以下几种，其他的，需要用的时候再查就行了。
  

```
	常用链路类型
	   0            BSD loopback devices, except for later OpenBSD
       1            Ethernet, and Linux loopback devices
       6            802.5 Token Ring
       7            ARCnet
       8            SLIP
       9            PPP
       10           FDDI
       100          LLC/SNAP-encapsulated ATM
       101          "raw IP", with no link
       102          BSD/OS SLIP
       103          BSD/OS PPP
       104          Cisco HDLC
       105          802.11
       108          later OpenBSD loopback devices (with the AF_value in network byte order)
       113          special Linux "cooked" capture
       114          LocalTalk
```


 - **Packet Header（共 16 Byte）**
 
 Packet Header可以有多个，每个Packet Header后面会跟着一串Packet Data，Packet Header定义了Packet Data的长度、时间戳等信息。
 ![包头格式]({{ site.baseurl }}/_posts/images/1494596685382.png)
 - **Timestamp：**被捕获时间的高位，单位是seconds
 - **Timestamp：**被捕获时间的低位，单位是microseconds
 - **Caplen：**当前数据区的长度，即抓取到的数据帧长度，不包括Packet Header本身的长度，单位是 Byte ，由此可以得到下一个数据帧的位置。
 - **Len：**离线数据长度：网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等。
 - **Packet Data（共 Caplen Byte）**
 在包头之后，就是数据包的数据了，数据长度就是Caplen个Byte，在这之后就是一个新的Packet Header，定义一个新的Packet Data属性，再接一个新的Packet Data，如此循环。

## 举个栗子 ##

```
d4c3 b2a1 0200 0400 0000 0000 0000 0000
ff7f 0000 0100 0000 

e5da c850 fbdc 0800 2a00 0000 2a00 0000 
ffff ffff ffff 0000 0000 0000 0800 4500 
001c 0001 0000 4032 7cad 7f00 0001 7f00 
0001 0102 0304 0000 0001 

eada c850 6d02 0100 2a00 0000 2a00 0000 
ffff ffff ffff 0000 0000 0000 0800 4500 
001c 0002 0000 4032 7cac 7f00 0001 7f00 
0001 0102 0304 0000 0002 

eeda c850 9824 0800 2a00 0000 2a00 0000 
ffff ffff ffff 0000 0000 0000 0800 4500 
001c 0003 0000 4032 7cab 7f00 0001 7f00 
0001 0102 0304 0000 0003 

f3da c850 250c 0100 2a00 0000 2a00 0000 
ffff ffff ffff 0000 0000 0000 0800 4500 
001c 0004 0000 4032 7caa 7f00 0001 7f00 
0001 0102 0304 0000 0004


2bdc c850 7952 0500 2a00 0000 2a00 0000
ffff ffff ffff 0000 0000 0000 0800 4500
001c 2710 0000 4032 559e 7f00 0001 7f00
0001 0102 0304 0000 2710 
```
上面是在ROHC库的测试文件里找出来的其中一个数据流文件，本来这些数据都是粘在一起的，我整理了一下让它变得更容易看一些。
例如第一段，

```
d4c3 b2a1 0200 0400 0000 0000 0000 0000
ff7f 0000 0100 0000 
```
就是Global Header，可以一一对应到上面所说的各个属性。

例如第二段，

```
e5da c850 fbdc 0800 2a00 0000 2a00 0000 
ffff ffff ffff 0000 0000 0000 0800 4500 
001c 0001 0000 4032 7cad 7f00 0001 7f00 
0001 0102 0304 0000 0001 
```
e5da c850 就是时间戳的高位
fbdc 0800 就是时间戳的低位
2a00 0000 就是数据包的大小，十六进制，转换成十进制，就是42 Byte
2a00 0000 就是抓到的包的大小
ffff ffff ffff 0000 0000 0000 0800 4500 
001c 0001 0000 4032 7cad 7f00 0001 7f00 
0001 0102 0304 0000 0001 就是数据包，长度一共是 42 Byte
然后就开始下一个数据包。


